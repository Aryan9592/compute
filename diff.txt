diff --git a/offchain-rust/computation/src/commitment.rs b/offchain-rust/computation/src/commitment.rs
index ab946b2..9fe0cb6 100644
--- a/offchain-rust/computation/src/commitment.rs
+++ b/offchain-rust/computation/src/commitment.rs
@@ -1,8 +1,10 @@
-use super::{interval::Interval, machine::Machine};
+use super::machine::Machine;
 use crate::constants;
 use cryptography::merkle_builder::MerkleBuilder;
 use cryptography::merkle_tree::MerkleTree;
 use utils::arithmetic;
+use std::collections::HashMap;
+use cryptography::hash::Hash;
 
 async fn run_uarch_span(machine: std::sync::Arc<std::sync::Mutex<Machine>>) -> MerkleTree {
     assert!(machine.lock().unwrap().ucycle == 0);
@@ -29,18 +31,19 @@ async fn run_uarch_span(machine: std::sync::Arc<std::sync::Mutex<Machine>>) -> M
 }
 
 async fn build_small_machine_commitment(
-    interval: Interval,
+    base_cycle: u64,
+    log2_stride_count: u8,
     machine: std::sync::Arc<std::sync::Mutex<Machine>>,
 ) -> (cryptography::hash::Hash, MerkleTree) {
     std::sync::Arc::clone(&machine)
         .lock()
         .unwrap()
-        .run(interval.base_meta_counter as u64)
+        .run(base_cycle)
         .await;
     let initial_state = machine.lock().unwrap().state().await.root_hash;
     let mut builder = MerkleBuilder::new();
     let instruction_count =
-        arithmetic::max_uint(interval.log2_stride_count - constants::LOG2_UARCH_SPAN);
+        arithmetic::max_uint(log2_stride_count as u32 - constants::LOG2_UARCH_SPAN);
     let mut instructions = 0;
 
     loop {
@@ -71,30 +74,33 @@ async fn build_small_machine_commitment(
             break;
         }
     }
+    println!("result hash {:?}", machine.lock().unwrap().state().await.root_hash);
     return (initial_state, builder.build());
 }
 
 async fn build_big_machine_commitment(
-    interval: Interval,
+    base_cycle: u64,
+    log2_stride: u32,
+    log2_stride_count: u8,
     machine: std::sync::Arc<std::sync::Mutex<Machine>>,
 ) -> (cryptography::hash::Hash, MerkleTree) {
     std::sync::Arc::clone(&machine)
         .lock()
         .unwrap()
-        .run(interval.base_meta_counter as u64)
+        .run(base_cycle)
         .await;
     let initial_state = machine.lock().unwrap().state().await.root_hash;
     let mut builder = MerkleBuilder::new();
     let instruction_count =
-        arithmetic::max_uint(interval.log2_stride_count - constants::LOG2_UARCH_SPAN);
+        arithmetic::max_uint(log2_stride_count as u32 - constants::LOG2_UARCH_SPAN);
     let mut instruction = 0;
 
     while arithmetic::ulte(instruction as u64, instruction_count as u64) {
-        let cycle = ((instruction + 1) << (interval.log2_stride - constants::LOG2_UARCH_SPAN));
+        let cycle = (instruction + 1) << (log2_stride - constants::LOG2_UARCH_SPAN);
         std::sync::Arc::clone(&machine)
             .lock()
             .unwrap()
-            .run(interval.base_meta_counter as u64 + cycle)
+            .run(base_cycle + cycle)
             .await;
         if !machine.lock().unwrap().state().await.halted {
             builder.add(machine.lock().unwrap().state().await.root_hash, None);
@@ -111,24 +117,61 @@ async fn build_big_machine_commitment(
 }
 
 async fn build_commitment(
-    interval: Interval,
+    base_cycle: u64,
+    log2_stride: u32,
+    log2_stride_count: u8,
     path: &str,
 ) -> (cryptography::hash::Hash, MerkleTree) {
     let machine = std::sync::Arc::new(std::sync::Mutex::new(Machine::new_from_path(path).await));
-    if interval.log2_stride >= constants::LOG2_UARCH_SPAN {
+    if log2_stride >= constants::LOG2_UARCH_SPAN{
         assert!(
-            interval.log2_stride - constants::LOG2_UARCH_SPAN + interval.log2_stride_count <= 63
+            log2_stride + log2_stride_count as u32 <=
+            constants::LOG2_EMULATOR_SPAN + constants::LOG2_UARCH_SPAN
         );
-        build_big_machine_commitment(interval, machine).await
+        build_big_machine_commitment(base_cycle, log2_stride, log2_stride_count, machine).await
     } else {
-        build_small_machine_commitment(interval, machine).await
+        build_small_machine_commitment(base_cycle, log2_stride_count, machine).await
+    }
+}
+
+struct CommitmentBuilder {
+    machine_path: String,
+    commitments: HashMap<usize, HashMap<usize, Hash>>,
+}
+
+impl CommitmentBuilder {
+    fn new(machine_path: String) -> Self {
+        CommitmentBuilder {
+            machine_path,
+            commitments: HashMap::new(),
+        }
+    }
+
+    async fn build(&mut self, base_cycle: u64, level: usize) -> Hash {
+        assert!(level <= constants::LEVELS);
+        if !self.commitments.contains_key(&level) {
+            self.commitments.insert(level, HashMap::new());
+        } else if self.commitments[&level].contains_key(&(base_cycle as usize)) {
+            return self.commitments[&level][&(base_cycle as usize)].clone();
+        }
+
+        let l = (constants::LEVELS - level + 1) as usize;
+        let log2_stride = constants::LOG2STEP[l];
+        let log2_stride_count = constants::HEIGHTS[l];
+
+        let (_, commitment) = build_commitment(base_cycle, log2_stride, log2_stride_count, &self.machine_path).await;
+        self.commitments
+            .entry(level)
+            .or_insert_with(HashMap::new)
+            .insert(base_cycle as usize, commitment.root_hash.clone());
+
+        commitment.root_hash
     }
 }
 
 pub async fn commitment_execution() {
-    let i = Interval::new(0, 0, 64);
     let path = "simple-program";
-    let tree = build_commitment(i, path).await;
+    let tree = build_commitment(0, 0, 64, path).await;
 
     println!("{:?}  {:?}", tree.0.digest_hex, tree.1.root_hash.digest_hex);
 }
diff --git a/offchain-rust/computation/src/constants.rs b/offchain-rust/computation/src/constants.rs
index 444d8fa..1f0b236 100644
--- a/offchain-rust/computation/src/constants.rs
+++ b/offchain-rust/computation/src/constants.rs
@@ -1,13 +1,13 @@
 use utils::arithmetic;
 
-pub const LEVELS: u32 = 4;
-pub const MAX_CYCLE: u32 = 63;
+pub const LEVELS: usize = 4;
+pub const MAX_CYCLE: u8 = 63;
 
 pub const LOG2STEP: [u32; 4] = [24, 14, 7, 0];
-pub const HEIGHTS: [u32; 4] = [39, 10, 7, 7];
+pub const HEIGHTS: [u8; 4] = [39, 10, 7, 7];
 
-pub const LOG2_UARCH_SPAN: u32 = 64;
+pub const LOG2_UARCH_SPAN: u32 = 16;
 pub const UARCH_SPAN: i64 = arithmetic::max_uint(LOG2_UARCH_SPAN);
 
-pub const LOG2_EMULATOR_SPAN: u32 = 63;
+pub const LOG2_EMULATOR_SPAN: u32 = 47;
 pub const EMULATOR_SPAN: i64 = arithmetic::max_uint(LOG2_EMULATOR_SPAN);
diff --git a/offchain-rust/computation/src/interval.rs b/offchain-rust/computation/src/interval.rs
deleted file mode 100644
index 92d5870..0000000
--- a/offchain-rust/computation/src/interval.rs
+++ /dev/null
@@ -1,196 +0,0 @@
-use crate::constants;
-use utils::arithmetic;
-#[derive(Clone, Debug)]
-pub struct StrideCounter {
-    interval: Interval,
-    total: i64,
-    value: i32,
-}
-
-impl StrideCounter {
-    pub fn new(interval: Interval, total: i64, v: Option<i32>) -> StrideCounter {
-        let value = match v {
-            Some(value) => value,
-            None => -1,
-        };
-        StrideCounter {
-            interval,
-            total,
-            value,
-        }
-    }
-
-    fn increment(&mut self) {
-        self.value += 1;
-    }
-
-    /*pub fn cycle(&self) -> u32 {
-        let cycle = (self.value << (self.interval.log2_stride - constants::A)) as u32;
-        cycle
-    }*/
-
-    fn ucycle(&self) -> u32 {
-        let ucycle = (self.value << self.interval.log2_stride) as u32;
-        ucycle
-    }
-
-    pub fn remaining_strides(&self) -> i64 {
-        self.total - self.value as i64
-    }
-}
-#[derive(Clone, Debug)]
-
-pub struct Interval {
-    pub base_meta_counter: u32,
-    pub log2_stride: u32,
-    pub log2_stride_count: u32,
-}
-
-impl Interval {
-    pub fn new(
-        base_meta_counter: u32,
-        log2_stride: u32,
-        log2_stride_count: u32,
-    ) -> Interval {
-        Interval {
-            base_meta_counter,
-            log2_stride,
-            log2_stride_count,
-        }
-    }
-
-    /*pub fn iter(&self, log2_total_strides: i32) -> IntervalIterator {
-        IntervalIterator::new(self.clone(), log2_total_strides)
-    }*/
-
-    pub fn _build_iter(&self, log2_total_strides: u32) -> (u64, StrideCounter) {
-        let total_strides = arithmetic::max_uint(log2_total_strides);
-        let stride = StrideCounter::new(self.clone(), total_strides.try_into().unwrap(), None);
-        (total_strides as u64, stride)
-    }
-
-    /*pub fn big_strides(&self) -> (u64, StrideCounter) {
-        let bid_strides_in_interval = if self.log2_stride_count >= constants::A {
-            self.log2_stride_count - constants::A
-        } else {
-            0
-        };
-
-        self._build_iter(bid_strides_in_interval)
-    }
-
-    pub fn big_strides_iter(&self) -> BigStridesIter {
-        BigStridesIter {
-            interval: self,
-            remaining_big_strides: self.log2_stride_count as u64,
-        }
-    }*/
-    
-
-    /*fn strides(&self) -> impl Iterator<Item = (u64, u64, u64)> {
-        let (total_strides, mut stride) = self._build_iter(self.log2_stride_count);
-        (0..total_strides).map(move |_| {
-            stride.increment();
-            (stride.value as u64, stride.cycle() as u64, stride.remaining_strides() as u64)
-        })
-    }*/
-
-    /*pub fn total_ucycles_in_cycle(&self) -> i32 {
-        let ucycles = std::cmp::min(constants::A, self.log2_stride_count);
-        arithmetic::max_uint(ucycles) as i32
-    }*/
-
-    /*pub fn ucycles_in_cycle(&self) -> IntervalIterator {
-        //println!("call total_ucycles_in_cycleeeeee");
-        println!("call total_ucycles_in_cycle from there");
-
-        let total_strides = self.total_ucycles_in_cycle();
-        println!("total strides {:?}", total_strides);
-        IntervalIterator::new(self.clone(), total_strides)
-    }*/
-
-    /*pub fn ucycles_in_cycle(&self) -> impl Iterator<Item = (u64, u64, u64)> {
-        let total_strides = self.total_ucycles_in_cycle();
-        let mut stride = StrideCounter::new(self.clone(), total_strides as i64, None);
-        (0..total_strides).map(move |_| {
-            stride.increment();
-            (stride.value as u64, stride.ucycle() as u64, stride.remaining_strides() as u64)
-        })
-    }
-
-    pub fn ucycles_in_cycle_iter(&self) -> UCyclesInCycleIter {
-        let total_ucycles_in_cycle = self.total_ucycles_in_cycle();
-
-        UCyclesInCycleIter {
-            interval: self,
-            remaining_ucycles_in_cycle: total_ucycles_in_cycle as u64,
-            remaining_strides: (total_ucycles_in_cycle << self.log2_stride) as u64,
-        }
-    }*/
-}
-/*
-pub struct BigStridesIter<'a> {
-    interval: &'a Interval,
-    remaining_big_strides: u64,
-}
-
-impl<'a> Iterator for BigStridesIter<'a> {
-    type Item = u64;
-
-    fn next(&mut self) -> Option<Self::Item> {
-        if self.remaining_big_strides > 0 {
-            self.remaining_big_strides -= 1;
-            Some(self.remaining_big_strides)
-        } else {
-            None
-        }
-    }
-}
-
-pub struct UCyclesInCycleIter<'a> {
-    interval: &'a Interval,
-    remaining_ucycles_in_cycle: u64,
-    remaining_strides: u64,
-
-}
-
-impl<'a> Iterator for UCyclesInCycleIter<'a> {
-    type Item = (i32, u64); // Return a tuple containing ucycle and remaining_strides
-
-    fn next(&mut self) -> Option<Self::Item> {
-        if self.remaining_ucycles_in_cycle > 0 {
-            let ucycle = self.interval.total_ucycles_in_cycle() - self.remaining_ucycles_in_cycle as i32;
-            self.remaining_ucycles_in_cycle -= 1;
-            let remaining_strides = self.remaining_strides;
-            self.remaining_strides -= 1;
-            Some((ucycle, remaining_strides))
-        } else {
-            None
-        }
-    }
-}
-#[derive(Debug)]
-pub struct IntervalIterator {
-    counter: StrideCounter,
-}
-
-impl IntervalIterator {
-    fn new(interval: Interval, log2_total_strides: i32) -> IntervalIterator {
-        let counter = StrideCounter::new( interval,  log2_total_strides as i64, None );
-        IntervalIterator { counter }
-    }
-}
-
-impl<'a> Iterator for IntervalIterator {
-    type Item = StrideCounter;
-
-    fn next(&mut self) -> Option<Self::Item> {
-        if self.counter.remaining_strides() > 0 {
-            self.counter.increment();
-            Some(self.counter.clone())
-        } else {
-            None
-        }
-    }
-}
-*/
diff --git a/offchain-rust/computation/src/machine.rs b/offchain-rust/computation/src/machine.rs
index 5e46e57..0ad2362 100644
--- a/offchain-rust/computation/src/machine.rs
+++ b/offchain-rust/computation/src/machine.rs
@@ -1,5 +1,4 @@
-use super::result::ComputationState;
-use cryptography::hash;
+use cryptography::hash::Hash;
 use utils::arithmetic;
 use jsonrpc_cartesi_machine::{JsonRpcCartesiMachineClient, MachineRuntimeConfig};
 use std::sync::{Arc, Mutex};
@@ -7,7 +6,8 @@ pub struct Machine {
     pub machine: Arc<Mutex<JsonRpcCartesiMachineClient>>,
     cycle: u64,
     pub ucycle: u64,
-    base_cycle: u64,
+    start_cycle: u64,
+    initial_hash: Hash,
 }
 
 impl Machine {
@@ -22,29 +22,21 @@ impl Machine {
             .load_machine(path, &MachineRuntimeConfig::default())
             .await
             .unwrap();
-
-        println!(
-            "start root {:?}",
-            hash::Hash::from_digest_bin(&machine.lock().unwrap().get_root_hash().await.unwrap())
-        );
-
         let start_cycle = machine
             .lock()
             .unwrap()
             .get_csr_address("mcycle".to_string())
             .await
             .unwrap();
-
-        println!("start cycle {:?}", start_cycle);
-
         // Machine can never be advanced on the micro arch.
         // Validators must verify this first
         assert_eq!(machine.lock().unwrap().get_csr_address("uarch_cycle".to_string()).await.unwrap(), 800);
         Machine {
-            machine,
+            machine: Arc::clone(&machine),
             cycle: 0,
             ucycle: 0,
-            base_cycle: start_cycle,
+            start_cycle,
+            initial_hash: Hash::from_digest_bin(&Arc::clone(&machine).lock().unwrap().get_root_hash().await.unwrap()),
         }
     }
 
@@ -60,7 +52,7 @@ impl Machine {
     }
     pub async fn run(&mut self, cycle: u64) {
         assert!(arithmetic::ulte(self.cycle, cycle));
-        let physical_cycle = Machine::add_and_clamp(self.base_cycle, cycle);
+        let physical_cycle = Machine::add_and_clamp(self.start_cycle, cycle);
         let machine = Arc::clone(&self.machine);
         while !(machine.lock().unwrap().read_iflags_h().await.unwrap()
             || machine
@@ -114,3 +106,43 @@ impl Machine {
         self.ucycle = 0;
     }
 }
+
+#[derive(Debug)]
+pub struct ComputationState  {
+    pub root_hash: Hash,
+    pub halted: bool,
+    pub uhalted: bool,
+}
+
+impl ComputationState  {
+    pub fn new(root_hash: Hash, halted: bool, uhalted: bool) -> ComputationState  {
+        ComputationState  {
+            root_hash,
+            halted,
+            uhalted,
+        }
+    }
+
+    pub async fn from_current_machine_state(machine: std::sync::Arc<std::sync::Mutex<JsonRpcCartesiMachineClient>>) -> ComputationState  {
+        let root_hash = Hash::from_digest_bin(&machine.lock().unwrap().get_root_hash().await.unwrap());
+        let halted = machine.lock().unwrap().read_iflags_h().await.unwrap();
+        let unhalted = machine.lock().unwrap().read_uarch_halt_flag().await.unwrap();
+        ComputationState::new(
+            root_hash,
+            halted,
+            unhalted,
+        )
+    }
+}
+
+impl std::fmt::Display for ComputationState {
+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
+        write!(
+            f,
+            "{{root_hash = {:?}, halted = {}, uhalted = {}}}",
+            self.root_hash,
+            self.halted,
+            self.uhalted
+        )
+    }
+}
\ No newline at end of file
diff --git a/offchain-rust/computation/src/mod.rs b/offchain-rust/computation/src/mod.rs
index 4a61a57..069c086 100644
--- a/offchain-rust/computation/src/mod.rs
+++ b/offchain-rust/computation/src/mod.rs
@@ -1,5 +1,4 @@
 pub mod commitment;
-pub mod interval;
 pub mod machine;
-pub mod result;
-pub mod constants;
\ No newline at end of file
+pub mod constants;
+pub mod fake_commitment;
\ No newline at end of file
diff --git a/offchain-rust/computation/src/result.rs b/offchain-rust/computation/src/result.rs
deleted file mode 100644
index 8b75ed8..0000000
--- a/offchain-rust/computation/src/result.rs
+++ /dev/null
@@ -1,42 +0,0 @@
-use cryptography::hash::Hash;
-use jsonrpc_cartesi_machine::JsonRpcCartesiMachineClient;
-#[derive(Debug)]
-pub struct ComputationState  {
-    pub root_hash: Hash,
-    pub halted: bool,
-    pub uhalted: bool,
-}
-
-impl ComputationState  {
-    pub fn new(root_hash: Hash, halted: bool, uhalted: bool) -> ComputationState  {
-        ComputationState  {
-            root_hash,
-            halted,
-            uhalted,
-        }
-    }
-
-    pub async fn from_current_machine_state(machine: std::sync::Arc<std::sync::Mutex<JsonRpcCartesiMachineClient>>) -> ComputationState  {
-        let root_hash = Hash::from_digest_bin(&machine.lock().unwrap().get_root_hash().await.unwrap());
-        let halted = machine.lock().unwrap().read_iflags_h().await.unwrap();
-        let unhalted = machine.lock().unwrap().read_uarch_halt_flag().await.unwrap();
-        ComputationState::new(
-            root_hash,
-            halted,
-            unhalted,
-        )
-    }
-}
-
-impl std::fmt::Display for ComputationState {
-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
-        write!(
-            f,
-            "{{root_hash = {:?}, halted = {}, uhalted = {}}}",
-            self.root_hash,
-            self.halted,
-            self.uhalted
-        )
-    }
-}
-
diff --git a/offchain-rust/cryptography/src/hash.rs b/offchain-rust/cryptography/src/hash.rs
index 6182abf..c6d1c84 100644
--- a/offchain-rust/cryptography/src/hash.rs
+++ b/offchain-rust/cryptography/src/hash.rs
@@ -60,18 +60,12 @@ impl Hash {
     }
 
     pub fn join(&self, other_hash: &Hash) -> Hash {
-        //println!("self.digest_hex {:?}", self.digest_hex);
-        //println!("other_hash.digest_hex {:?}", other_hash.digest_hex);
-
         let mut keccak = Keccak256::new();
         keccak.update(&hex::decode(&self.digest_hex[2..]).unwrap());
         keccak.update(&hex::decode(&other_hash.digest_hex[2..]).unwrap());
         let digest = keccak.finalize();
-        //println!("digest {:?}", digest);
         let digest_hex = hex_from_bin(&digest);
-        //println!("digest_hex {:?}", digest_hex);
         let mut ret = Hash::from_digest(&digest_hex);
-        //println!("ret {:?}", ret);
         ret.left = Some(self.digest_hex.clone());
         ret.right = Some(other_hash.digest_hex.clone());
         ret
@@ -127,6 +121,6 @@ fn zero_bytes32() -> String {
     "0x0000000000000000000000000000000000000000000000000000000000000000".to_string()
 }
 
-fn zero_hash() -> Hash {
+pub fn zero_hash() -> Hash {
     Hash::from_digest(&zero_bytes32())
 }
diff --git a/offchain-rust/cryptography/src/merkle_builder.rs b/offchain-rust/cryptography/src/merkle_builder.rs
index 2e29143..7f00fef 100644
--- a/offchain-rust/cryptography/src/merkle_builder.rs
+++ b/offchain-rust/cryptography/src/merkle_builder.rs
@@ -118,7 +118,7 @@ pub struct Leaf {
     accumulated_count: u64,
 }
 
-fn merkle(leafs: &Slice, log2size: u32, stride: usize) -> Hash {
+fn merkle(leafs: &Slice, log2size: u32, stride: u64) -> Hash {
     let first_time = stride * (1 << log2size) + 1;
     let shifting = (1 as u64).checked_shl(log2size);
     let last_time = match shifting {
diff --git a/offchain-rust/utils/src/arithmetic.rs b/offchain-rust/utils/src/arithmetic.rs
index 8196609..2eceaf7 100644
--- a/offchain-rust/utils/src/arithmetic.rs
+++ b/offchain-rust/utils/src/arithmetic.rs
@@ -1,13 +1,10 @@
 pub const fn max_uint(k: u32) -> i64 {
-    //println!("k {:?}", k);
     assert!(k <= 64);
     let shifting = (1 as u64).checked_shl(k);
     let result: i64 = match shifting {
         Some(sh) => (sh - 1) as i64,
         None => -1,
     };
-    //println!("return {:?}", result);
-
     result
 }
 
diff --git a/offchain-rust/utils/src/bint.rs b/offchain-rust/utils/src/bint.rs
deleted file mode 100644
index 47cab89..0000000
--- a/offchain-rust/utils/src/bint.rs
+++ /dev/null
@@ -1,780 +0,0 @@
-/*use std::ops::{Mul, Neg, Not};
-
-const BINT_SIZE: usize = 4;
-const BINT_BITS: i64 = 64;
-const BINT_WORDBITS: i64 = 32;
-const BINT_WORDMAX: u64 = u64::MAX;
-const BINT_WORDMSB: u64 = 0x8000_0000;
-const BINT_MININTEGER: u64 = Bint::bint_mininteger();
-#[derive(Debug, Clone, PartialEq, Default)]
-struct Bint {
-    value: [u64; BINT_SIZE],
-}
-
-impl Bint {
-    fn zero() -> Self {
-        Self {
-            value: [0; BINT_SIZE],
-        }
-    }
-
-    fn one() -> Self {
-        let mut value = [0; BINT_SIZE];
-        value[0] = 1;
-        Self { value }
-    }
-
-    fn is_zero(&self) -> bool {
-        self.value.iter().all(|&x| x == 0)
-    }
-
-    fn inc(&mut self) -> Result<(), &'static str> {
-        let mut carry = 1;
-        for i in 0..BINT_SIZE {
-            let (result, overflow) = self.value[i].overflowing_add(carry);
-            self.value[i] = result;
-            if !overflow {
-                break;
-            }
-            carry = 1;
-        }
-        if carry != 0 {
-            Err("increment overflow")
-        } else {
-            Ok(())
-        }
-    }
-
-    fn shl(&self, shift: i64) -> Result<Self, &'static str> {
-        if shift == std::i64::MIN || shift.abs() >= BINT_BITS {
-            return Ok(Self::zero());
-        }
-        if shift < 0 {
-            return self.shr(-shift);
-        }
-        let nvals = shift / BINT_WORDBITS;
-        let mut result = self.shl_words(nvals)?;
-        let mut shift = shift - nvals * BINT_WORDBITS;
-        if shift != 0 {
-            let wordbitsmy = BINT_WORDBITS - shift;
-            for i in 0..BINT_SIZE - 1 {
-                result.value[i] = ((result.value[i] << shift)
-                    | (result.value[i + 1] >> wordbitsmy))
-                    & BINT_WORDMAX;
-            }
-            result.value[BINT_SIZE - 1] = (result.value[BINT_SIZE - 1] << shift) & BINT_WORDMAX;
-        }
-        Ok(result)
-    }
-
-    fn shr(&self, shift: i64) -> Result<Self, &'static str> {
-        if shift == std::i64::MIN || shift.abs() >= BINT_BITS {
-            return Ok(Self::zero());
-        }
-        if shift < 0 {
-            return self.shl(-shift);
-        }
-        let nvals = shift / BINT_WORDBITS;
-        let mut result = self.shr_words(nvals)?;
-        let mut shift = shift - nvals * BINT_WORDBITS;
-        if shift != 0 {
-            let wordbitsmy = BINT_WORDBITS - shift;
-            for i in 0..BINT_SIZE - 1 {
-                result.value[i] = ((result.value[i] >> shift)
-                    | (result.value[i + 1] << wordbitsmy))
-                    & BINT_WORDMAX;
-            }
-            result.value[BINT_SIZE - 1] = result.value[BINT_SIZE - 1] >> shift;
-        }
-        Ok(result)
-    }
-
-    fn shl_words(&self, nvals: i64) -> Result<Self, &'static str> {
-        let mut result = Self::zero();
-        if nvals > BINT_SIZE as i64 {
-            return Ok(result);
-        }
-        for i in nvals as usize..BINT_SIZE {
-            result.value[i] = self.value[i - nvals as usize];
-        }
-        Ok(result)
-    }
-
-    fn shr_words(&self, nvals: i64) -> Result<Self, &'static str> {
-        let mut result = Self::zero();
-        if nvals > BINT_SIZE as i64 {
-            return Ok(result);
-        }
-        for i in 0..(BINT_SIZE - nvals as usize) {
-            result.value[i] = self.value[i + nvals as usize];
-        }
-        Ok(result)
-    }
-
-    fn bint_mininteger() -> Bint {
-        let mut x = Bint::default();
-        for i in 0..BINT_SIZE - 1 {
-            x.value[i] = 0;
-        }
-        x.value[BINT_SIZE - 1] = BINT_WORDMSB;
-        x
-    }
-
-    fn isneg(x: &Bint) -> bool {
-        if let Some(x) = tobint(x) {
-            return x.value[BINT_SIZE - 1] & BINT_WORDMSB != 0;
-        }
-        if let Some(x) = bint_tonumber(x) {
-            return x < 0;
-        }
-        false
-    }
-
-    fn is_one(x: &Bint) -> bool {
-        if let Some(x) = tobint(x) {
-            if x.value[0] != 1 {
-                return false;
-            }
-            for i in 1..BINT_SIZE {
-                if x.value[i] != 0 {
-                    return false;
-                }
-            }
-            return true;
-        }
-        if let Some(x) = bint_tonumber(x) {
-            return x == 1;
-        }
-        false
-    }
-
-    fn is_odd(x: &Bint) -> bool {
-        if let Some(x) = tobint(x) {
-            return x.value[0] & 1 == 1;
-        }
-        if let Some(x) = bint_tonumber(x) {
-            return x.abs() % 2 == 1;
-        }
-        false
-    }
-
-    fn shrone(&mut self) {
-        let wordbitsm1 = BINT_WORDBITS - 1;
-        for i in 0..(BINT_SIZE - 1) {
-            self.value[i] = ((self.value[i] >> 1) | (self.value[i + 1] << wordbitsm1)) & BINT_WORDMAX;
-        }
-        self.value[BINT_SIZE - 1] >>= 1;
-    }
-
-    fn dec(&mut self) {
-        for i in 0..BINT_SIZE {
-            let tmp = self.value[i];
-            let v = (tmp - 1) & BINT_WORDMAX;
-            self.value[i] = v;
-            if !(v > tmp) {
-                break;
-            }
-        }
-    }
-
-    fn tointeger(&self) -> Option<i64> {
-        if self.is_bint() {
-            let mut n: i64 = 0;
-            let neg = self.is_neg();
-            let mut x = self.clone();
-            if neg {
-                x = -x;
-            }
-            for i in 1..=BINT_SIZE {
-                n |= (x[i] << (BINT_WORDBITS * (i - 1))) as i64;
-            }
-            if neg {
-                n = -n;
-            }
-            Some(n)
-        } else {
-            to_integer(x)
-        }
-    }
-
-    fn unm(&mut self) -> &mut Self {
-        self.bnot().inc();
-        self
-    }
-
-    fn abs(&mut self) {
-        if self.isneg() {
-            self._unm();
-        }
-    }
-
-    fn is_even(x: &Bint) -> bool {
-        if let Some(bint) = x.downcast_ref::<Bint>() {
-            bint.value[0] & 1 == 0
-        } else if let Some(num) = x.downcast_ref::<i64>() {
-            num.abs() % 2 == 0
-        } else {
-            false
-        }
-    }
-
-    fn tobase(x: &Bint, base: u32, unsigned: Option<bool>) -> Option<String> {
-        if let Some(bint) = x.downcast_ref::<Bint>() {
-            if unsigned.is_none() {
-                unsigned = Some(base != 10);
-            }
-            let is_x_neg = Bint:isneg(bint);
-            if (base == 10 && unsigned.unwrap()) || (base == 16 && unsigned.unwrap() && !is_x_neg) {
-                if bint <= BINT_MATHMAXINTEGER && bint >= BINT_MATHMININTEGER {
-                    let n = bint.tointeger().unwrap();
-                    if base == 10 {
-                        return Some(n.to_string());
-                    } else if unsigned.unwrap() {
-                        return Some(format!("{:x}", n));
-                    }
-                }
-            }
-            let mut ss = Vec::new();
-            let neg = !unsigned.unwrap_or(base == 10) && is_x_neg;
-            let mut x = if neg { 
-                bint.abs();
-                bint 
-            } else {
-                &bint_new(x).unwrap() 
-            };
-            let x_is_zero = x.is_zero();
-            if x_is_zero {
-                return Some("0".to_string());
-            }
-            let step = get_base_step(base);
-            let basepow = ipow(1, base as u64, step.try_into().unwrap());
-            let mut size = BINT_SIZE;
-            let mut xd;
-            let mut carry;
-            let mut d;
-            loop {
-                carry = 0;
-                let mut x_is_zero = true;
-                for i in (0..size).rev() {
-                    carry |= x.value[i];
-                    d = carry / basepow;
-                    xd = carry % basepow
-                    if x_is_zero && d != 0 {
-                        size = i;
-                        x_is_zero = false;
-                    }
-                    x.value[i] = d;
-                    carry = xd << BINT_WORDBITS;
-                }
-                for _ in 0..step {
-                    let div = xd.divmod(base);
-                    xd = div.0;
-                    d = div.1;
-                    if x_is_zero && xd == 0 && d == 0 {
-                        break;
-                    }
-                    ss.insert(0, BASE_LETTERS[d as usize]);
-                }
-                if x_is_zero {
-                    break;
-                }
-            }
-            if neg {
-                ss.insert(0, '-');
-            }
-            Some(ss.iter().collect())
-        } else {
-            None
-        }
-    }
-  
-}
-
-impl Not for Bint {
-    type Output = Bint;
-
-    fn not(self) -> Bint {
-        let mut y = Bint{value:[0; BINT_SIZE]};
-        for i in 0..BINT_SIZE {
-            y.0[i] = !self.0[i] & BINT_WORDMAX;
-        }
-        y
-    }
-}
-
-impl Mul for Bint {
-    type Output = Bint;
-
-    fn mul(self, other: Bint) -> Bint {
-        let ix = tobint(&self);
-        let iy = tobint(&other);
-
-        if let (Some(ix), Some(iy)) = (ix, iy) {
-            let mut z = Bint::zero();
-            let sizep1 = BINT_SIZE + 1;
-            let mut s = sizep1;
-            let mut e = 0;
-
-            for i in 1..=BINT_SIZE {
-                if ix[i] != 0 || iy[i] != 0 {
-                    e = e.max(i);
-                    s = s.min(i);
-                }
-            }
-
-            for i in s..=e {
-                for j in s..=(sizep1 - i).min(e) {
-                    let a = ix[i] * iy[j];
-
-                    if a != 0 {
-                        let mut carry = 0;
-
-                        for k in (i + j - 1)..=BINT_SIZE {
-                            let tmp = z[k] + (a & BINT_WORDMAX) + carry;
-                            carry = tmp >> BINT_WORDBITS;
-                            z[k] = tmp & BINT_WORDMAX;
-                            a >>= BINT_WORDBITS;
-                        }
-                    }
-                }
-            }
-
-            z
-        } else {
-            Bint::from(bint_tonumber(&self) * bint_tonumber(&other))
-        }
-    }
-}
-
-impl Neg for Bint {
-    type Output = Bint;
-
-    fn neg(self) -> Bint {
-        !self.inc()
-    }
-}
-
-fn to_integer(x: f64) -> Option<i64> {
-    let mut x = x;
-    let ty = x.classify();
-    if ty == FpCategory::Normal || ty == FpCategory::Zero {
-        let floor_x = x.floor();
-        if floor_x == x {
-            x = floor_x;
-        }
-    }
-    if x.is_finite() && x.fract() == 0.0 {
-        Some(x as i64)
-    } else {
-        None
-    }
-}
-
-fn tobint(x: &Bint) -> Option<[u64; BINT_SIZE]> {
-    x.downcast_ref::<Bint>().map(|b| b.value)
-}
-
-fn is_bint(x: &Bint) -> bool {
-    x.is::<Bint>()
-}
-
-
-fn bint_assert_convert(x: &Bint) -> Result<Bint, &'static str> {
-    if let Some(b) = tobint(x) {
-        Ok(Bint { value: b })
-    } else {
-        Err("invalid conversion to bint")
-    }
-}
-
-fn bint_assert_tointeger(x: &Bint) -> Result<i64, &'static str> {
-    if let Some(b) = x.downcast_ref::<i64>() {
-        Ok(*b)
-    } else {
-        Err("invalid conversion to integer")
-    }
-}
-
-fn bint_new(x: &Bint) -> Result<Bint, &'static str> {
-    if let Some(b) = tobint(x) {
-        Ok(Bint { value: b })
-    } else if let Some(n) = x.downcast_ref::<i64>() {
-        Ok(Bint::new(*n))
-    } else {
-        Err("invalid conversion to bint")
-    }
-}
-
-fn bint_tonumber(x: &Bint) -> f64 {
-    if let Some(b) = tobint(x) {
-        let mut result: u64 = 0;
-        for i in (0..BINT_SIZE).rev() {
-            result = result.wrapping_mul(2u64.pow(32));
-            result = result.wrapping_add(b[i]);
-        }
-        if b[BINT_SIZE - 1] & BINT_WORDMSB != 0 {
-            result as i64 as f64
-        } else {
-            result as f64
-        }
-    } else if let Some(n) = x.downcast_ref::<i64>() {
-        *n as f64
-    } else {
-        0.0
-    }
-}
-
-fn bint_div(x: &Bint, y: &Bint) -> f64 {
-    bint_tonumber(x) / bint_tonumber(y)
-}
-
-fn bint_mod(x: &Bint, y: &Bint) -> f64 {
-    let nx = bint_tonumber(x);
-    let ny = bint_tonumber(y);
-    nx % ny
-}
-
-fn bint_eq(x: &Bint, y: &Bint) -> bool {
-    bint_tonumber(x) == bint_tonumber(y)
-}
-
-fn bint_ne(x: &Bint, y: &Bint) -> bool {
-    bint_tonumber(x) != bint_tonumber(y)
-}
-
-fn bint_abs(x: &Bint) -> Bint {
-    let mut result = bint_new(x).unwrap();
-    result.value[BINT_SIZE - 1] &= !BINT_WORDMSB;
-    result
-}
-
-fn udivmod(x: &Bint, y: &Bint) -> (Bint, Bint) {
-    let mut nume = bint_new(x);
-    let deno = bint_assert_convert(y);
-
-    let mut ishighzero = true;
-    for i in 2..BINT_SIZE {
-        if deno[i] != 0 {
-            ishighzero = false;
-            break;
-        }
-    }
-
-    if ishighzero {
-        let low = deno[1];
-        assert!(low != 0, "attempt to divide by zero");
-        if low == 1 {
-            return (nume, bint_zero());
-        } else if low <= (BINT_WORDMSB - 1) {
-            let rema = sudivmod(&mut nume, low);
-            return (nume.unwrap(), bint_fromuinteger(rema));
-        }
-    }
-
-    if nume.ult(&deno) {
-        return (bint_zero(), nume);
-    }
-
-    let denolbit = findleftbit(&deno);
-    let (numelbit, numesize) = findleftbit(&nume);
-    let bit = numelbit - denolbit;
-    let mut deno = deno << bit;
-    let wordmaxp1 = BINT_WORDMAX + 1;
-    let wordbitsm1 = BINT_WORDBITS - 1;
-    let mut denosize = numesize;
-    let mut quot = bint_zero();
-
-    while bit >= 0 {
-        let mut le = true;
-        let size = numesize.max(denosize);
-        for i in (1..=size).rev() {
-            let a = deno[i];
-            let b = nume[i];
-            if a != b {
-                le = a < b;
-                break;
-            }
-        }
-
-        if le {
-            let mut borrow = 0;
-            for i in 1..=size {
-                let res = nume[i] + wordmaxp1 - deno[i] - borrow;
-                nume[i] = res & BINT_WORDMAX;
-                borrow = (res >> BINT_WORDBITS) ^ 1;
-            }
-
-            let i = (bit / BINT_WORDBITS) + 1;
-            quot[i] |= 1 << (bit % BINT_WORDBITS);
-        }
-
-        for i in 1..denosize {
-            deno[i] = ((deno[i] >> 1) | (deno[i + 1] << wordbitsm1)) & BINT_WORDMAX;
-        }
-        let lastdenoword = deno[denosize] >> 1;
-        deno[denosize] = lastdenoword;
-
-        if lastdenoword == 0 {
-            while deno[denosize] == 0 {
-                denosize -= 1;
-            }
-            if denosize == 0 {
-                break;
-            }
-        }
-
-        bit -= 1;
-    }
-
-    (quot, nume)
-}
-
-
-fn bint_umod(x: &Bint, y: &Bint) -> Bint {
-    let (_, rema) = bint_udivmod(x, y);
-    rema
-}
-
-fn bint_tdivmod(x: &Bint, y: &Bint) -> (Bint, Bint) {
-    let ax = bint_abs(x);
-    let ay = bint_abs(y);
-    let mut quot = Bint::zero();
-    let mut rema = ax.clone();
-    if bint_eq(x, &BINT_MININTEGER) && bint_eq(y, &bint_minus_one()) {
-        panic!("division overflow");
-    }
-    while !rema.is_zero() && bint_ult(&ay, &rema) {
-        quot.inc().unwrap();
-        rema -= ay.clone();
-    }
-    let isxneg = x.is_neg();
-    let isyneg = y.is_neg();
-    if isxneg != isyneg {
-        quot = -quot;
-    }
-    if isxneg {
-        rema = -rema;
-    }
-    (quot, rema)
-}
-
-fn bint_tdiv(x: &Bint, y: &Bint) -> Bint {
-    let (quot, _) = bint_tdivmod(x, y);
-    quot
-}
-
-fn bint_tmod(x: &Bint, y: &Bint) -> Bint {
-    let (_, rema) = bint_tdivmod(x, y);
-    rema
-}
-
-fn bint_ipow(x: &Bint, y: &Bint) -> Bint {
-    let y = bint_assert_convert(y).unwrap();
-    if y.is_zero() {
-        return Bint::one();
-    } else if y == Bint::one() {
-        return bint_new(x).unwrap();
-    }
-    let mut x = bint_new(x).unwrap();
-    let mut y = y.clone();
-    let mut z = Bint::one();
-    while Bint::is_one(&!y) {
-        if Bint::is_even(&y) {
-            x = x.clone() * x.clone();
-            y.shrone();
-        } else {
-            z = x.clone() * z.clone();
-            x = x.clone() * x.clone();
-            y.dec();
-            y.shrone();
-        }
-    }
-    x = x * z;
-    x
-}
-fn bint_upowmod(x: &Bint, y: &Bint, m: &Bint) -> Bint {
-    let m = bint_assert_convert(m).unwrap();
-    if Bint::is_one(&m) {
-        return Bint::zero();
-    }
-    let mut x = bint_new(x).unwrap();
-    let mut y = bint_new(y).unwrap();
-    let mut z = Bint::one();
-    x = bint_umod(&x, &m)
-    while !y.is_zero() {
-        if Bint::is_odd(&y) {
-            z = bint_umod(&(z*x), &m)
-        }
-        y.shrone();
-        x = bint_umod(&(x*x), &m)
-    }
-    z
-}
-
-fn bint_umod(x: &Bint, y: &Bint) -> Bint {
-    let (_, rema) = bint_udivmod(x, y);
-    rema
-}
-
-fn get_base_step(base: u32) -> usize {
-    let mut step = 0;
-    let mut dmax = 1;
-    let limit = std::i64::MAX / base as i64;
-    loop {
-        step += 1;
-        dmax *= base;
-        if i64::from(dmax) >= limit {
-            break;
-        }
-    }
-    step
-}
-
-fn bint_shl(x: &Bint, y: &Bint) -> Result<Bint, &'static str> {
-    let x = bint_new(x)?;
-    let y = bint_assert_tointeger(y)?;
-    if y == std::i64::MIN || y.abs() >= BINT_BITS {
-        Ok(Bint::zero())
-    } else if y < 0 {
-        Ok(x.shr(-y)?)
-    } else {
-        let nvals = y / BINT_WORDBITS;
-        if nvals != 0 {
-            Ok(x.shl_words(nvals)?.shl(y - nvals * BINT_WORDBITS)?)
-        } else {
-            Ok(x.shl(y)?)
-        }
-    }
-}
-
-fn bint_band(x: &Bint, y: &Bint) -> Result<Bint, &'static str> {
-    let x = bint_new(x)?;
-    let mut y = bint_assert_convert(y)?;
-    for i in 0..BINT_SIZE {
-        y.value[i] &= x.value[i];
-    }
-    Ok(y)
-}
-
-fn bint_bor(x: &Bint, y: &Bint) -> Result<Bint, &'static str> {
-    let x = bint_new(x)?;
-    let mut y = bint_assert_convert(y)?;
-    for i in 0..BINT_SIZE {
-        y.value[i] |= x.value[i];
-    }
-    Ok(y)
-}
-
-fn bint_bxor(x: &Bint, y: &Bint) -> Result<Bint, &'static str> {
-    let x = bint_new(x)?;
-    let mut y = bint_assert_convert(y)?;
-    for i in 0..BINT_SIZE {
-        y.value[i] ^= x.value[i];
-    }
-    Ok(y)
-}
-
-fn bint_bnot(x: &Bint) -> Result<Bint, &'static str> {
-    let mut y = bint_assert_convert(x)?;
-    for i in 0..BINT_SIZE {
-        y.value[i] = (!y.value[i]) & BINT_WORDMAX;
-    }
-    Ok(y)
-}
-
-fn bint_unm(x: &Bint) -> Result<Bint, &'static str> {
-    let mut x = bint_assert_convert(x)?;
-    x = !x;
-    x.inc();
-    Ok(x)
-}
-
-fn bint_ult(x: &Bint, y: &Bint) -> bool {
-    let x = bint_assert_convert(x).unwrap();
-    let y = bint_assert_convert(y).unwrap();
-    for i in (0..BINT_SIZE).rev() {
-        if x.value[i] != y.value[i] {
-            return x.value[i] < y.value[i];
-        }
-    }
-    false
-}
-
-fn bint_ule(x: &Bint, y: &Bint) -> bool {
-    let x = bint_assert_convert(x).unwrap();
-    let y = bint_assert_convert(y).unwrap();
-    for i in (0..BINT_SIZE).rev() {
-        if x.value[i] != y.value[i] {
-            return x.value[i] < y.value[i];
-        }
-    }
-    true
-}
-
-fn bint_lt(x: &Bint, y: &Bint) -> bool {
-    let ix = tobint(x);
-    let iy = tobint(y);
-    if let (Some(ix), Some(iy)) = (ix, iy) {
-        let xneg = ix[BINT_SIZE - 1] & BINT_WORDMSB != 0;
-        let yneg = iy[BINT_SIZE - 1] & BINT_WORDMSB != 0;
-        if xneg == yneg {
-            for i in (0..BINT_SIZE).rev() {
-                if ix[i] != iy[i] {
-                    return ix[i] < iy[i];
-                }
-            }
-            false
-        } else {
-            xneg && !yneg
-        }
-    } else {
-        bint_tonumber(x) < bint_tonumber(y)
-    }
-}
-
-fn bint_le(x: &Bint, y: &Bint) -> bool {
-    let ix = tobint(x);
-    let iy = tobint(y);
-    if let (Some(ix), Some(iy)) = (ix, iy) {
-        let xneg = ix[BINT_SIZE - 1] & BINT_WORDMSB != 0;
-        let yneg = iy[BINT_SIZE - 1] & BINT_WORDMSB != 0;
-        if xneg == yneg {
-            for i in (0..BINT_SIZE).rev() {
-                if ix[i] != iy[i] {
-                    return ix[i] < iy[i];
-                }
-            }
-            true
-        } else {
-            xneg && !yneg
-        }
-    } else {
-        bint_tonumber(x) <= bint_tonumber(y)
-    }
-}
-
-fn ipow(y: u64, x: u64, n: u32) -> u64 {
-    if n == 1 {
-        return y * x;
-    } else if n & 1 == 0 {
-        return ipow(y, x * x, n / 2);
-    }
-    ipow(x * y, x * x, (n - 1) / 2)
-}
-
-impl std::fmt::Display for Bint {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{}", Bint::tobase(self, 10, None).unwrap())
-    }
-}
-
-fn newmodule() -> Result<Bint, &'static str> {
-    let bint = Bint::zero();
-    Ok(bint)
-}
-
-fn main() {
-    let bint = newmodule().unwrap();
-    println!("{:?}", bint);
-}
-*/
\ No newline at end of file
diff --git a/offchain-rust/utils/src/mod.rs b/offchain-rust/utils/src/mod.rs
index 965db62..55c211d 100644
--- a/offchain-rust/utils/src/mod.rs
+++ b/offchain-rust/utils/src/mod.rs
@@ -1 +1,2 @@
 pub mod arithmetic;
+pub mod eth_ebi;
\ No newline at end of file
